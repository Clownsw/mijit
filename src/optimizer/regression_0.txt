#[test]
fn regression_0() {
    // This was once `random_ebb(0, 2)` but both have since changed.
    let ebb = cb::build(|mut b| {
        b.binary64(Xor, R[2], R[3], R[4]);
        b.binary64(Lt, R[3], R[3], R[4]);
        b.guard(R[3], false, cb::build(|b| b.jump(0)));
        b.binary64(Lt, R[2], R[2], R[2]);
        b.jump(1)
    });
    optimize_and_compare(ebb, random_ebb_convention());
}

dataflow = Dataflow[
    Node(0): (Out(0), Out(1), Out(2), Out(3)) <- Convention (),
    Node(1): (Out(4)) <- Binary(P64, Xor) (Out(2), Out(3)),
    Node(2): (Out(5)) <- Binary(P64, Lt) (Out(2), Out(3)),
    Node(3): () <- Guard (Out(5)) after (Node(0)),
    Node(4): () <- Convention (Out(0), Out(4), Out(5), Out(3)) after (Node(3), Node(0), Node(0)),
    Node(5): (Out(6)) <- Binary(P64, Lt) (Out(4), Out(4)),
    Node(6): () <- Convention (Out(0), Out(6), Out(5), Out(3)) after (Node(3), Node(0), Node(0)),
]

input_map = {
    Out(0): Register(1),
    Out(1): Register(2),
    Out(2): Register(3),
    Out(3): Register(4),
}

walk {
    colds = {
        Node(3): Cold {
            cases: [(hot path)],
            default_: Merge {exit: Node(4), leaf: 0x0},
        },
    }
    exit = Node(6)
    leaf = 0x1

    fill = Fill {
        marker: 0x2,
        nodes: [Node(2), Node(3), Node(1), Node(5), Node(6)],
        frontier: Frontier {inputs: {Out(0), Out(2), Out(3)}},
    }
    guard_failures = {
        Node(3): GuardFailure {
            cases: [(hot path)],
            default_: Merge {exit: Node(4), leaf: 0x0},
            inputs: {Out(0), Out(3), Out(4), Out(5)},
        },
    }
    fill = Fill {
        marker: 0x2,
        nodes: [Node(2), Node(3), Node(1), Node(5), Node(6)],
        frontier: Frontier {inputs: {Out(0), Out(2), Out(3)}},
    }

    variables = {
        Out(0): Register(1),
        Out(2): Register(3),
        Out(3): Register(4),
    }

    Keep-alives for Node(6) are [Out(0), Out(6), Out(5), Out(3)]
    Keep-alives for Node(5) are [Out(4), Out(4)]
    Keep-alives for Node(1) are [Out(2), Out(3)]
    inputs of Node(3) = {Out(0), Out(3), Out(4), Out(5)}
    Keep-alives for Node(3) are [Out(5), Out(5), Out(3), Out(4), Out(0)]
    Keep-alives for Node(2) are [Out(2), Out(3)]

    add_node(Node(2), 2)
    keep_alives = [Out(2), Out(3)]
    Out(2) was written at time Some(Time(0)) with latency 0
    Out(3) was written at time Some(Time(0)) with latency 0
    Register(12) becomes available at time Time(0)
    Keep-alive Out(3) is currently in Some(Register(4))
    Marking it as used at time Time(0)
    Keep-alive Out(2) is currently in Some(Register(3))
    Marking it as used at time Time(0)
    Marking Out(5) as written at time Time(0) with latency 2

    add_node(Node(3), 5)
    keep_alives = [Out(0), Out(4), Out(3), Out(5), Out(5)]
    Out(5) was written at time Some(Time(2)) with latency 0
    Keep-alive Out(0) is currently in Some(Register(1))
    Marking it as used at time Time(2)
    Keep-alive Out(4) is currently in None // Because Node(1) has not yet been placed.
    Keep-alive Out(3) is currently in Some(Register(4))
    Marking it as used at time Time(2)
    Keep-alive Out(5) is currently in Some(Register(12))
    Marking it as used at time Time(2)
    Keep-alive Out(5) is currently in Some(Register(12))
    Marking it as used at time Time(2)

    add_node(Node(1), 2)
    keep_alives = [Out(3), Out(2)]
    Out(2) was written at time Some(Time(0)) with latency 0
    Out(3) was written at time Some(Time(0)) with latency 0
    Register(3) becomes available at time Time(0)
    Keep-alive Out(3) is currently in Some(Register(4))
    Marking it as used at time Time(0)
    Keep-alive Out(2) is currently in Some(Register(3))
    Marking it as used at time Time(0)
    Marking Out(4) as written at time Time(0) with latency 1

    add_node(Node(5), 2)
    keep_alives = [Out(4), Out(4)]
    Out(4) was written at time Some(Time(1)) with latency 0
    Out(4) was written at time Some(Time(1)) with latency 0
    Register(3) becomes available at time Time(0) // Wrong! it becomes available at Time(2).
    Keep-alive Out(4) is currently in Some(Register(3))
    Marking it as used at time Time(1)
    Keep-alive Out(4) is currently in Some(Register(3))
    Marking it as used at time Time(1)
    Marking Out(6) as written at time Time(1) with latency 2

    instructions = [
        Node(2): (Out(5)) <- Binary(P64, Lt) (Out(2), Out(3)),
        Node(1): (Out(4)) <- Binary(P64, Xor) (Out(2), Out(3)),
        Node(5): (Out(6)) <- Binary(P64, Lt) (Out(4), Out(4)),
        Node(3): () <- Guard (Out(5)) after (Node(0)),
    ]
    allocation = [
        Out(5): Register(12),
        Out(4): Register(3),
        Out(6): Register(3), // Clobbers Out(4), which is needed by Node(3).
    ]

    Doing Node(2)
    Doing Node(1)
    Doing Node(5)
    Doing Node(3)

    walk {
        colds = {}
        exit = Node(4)
        leaf = 0x0

        fill = Fill {
            marker: 0x3,
            nodes: [Node(4)],
            frontier: Frontier {inputs: {Out(0), Out(3), Out(4), Out(5)}},
        }
        guard_failures = {}
        fill = Fill {
            marker: 0x3,
            nodes: [Node(4)],
            frontier: Frontier {inputs: {Out(0), Out(3), Out(4), Out(5)}},
        }

        variables = {
            Out(0): Register(1),
            Out(3): Register(4),
            Out(4): Register(3),
            Out(5): Register(12),
        }
        instructions = []
        allocation = [
            Out(3): Register(4),
            Out(4): Register(3),
            Out(5): Register(12),
        ]
        ret = EBB {
            actions: [
                Move Register(2), Register(3),
                Move Register(3), Register(12),
            ],
            ending: Leaf(
                0x0,
            ),
        }
    }

    ret = EBB {
        actions: [
            Lt_P64 Register(12), Register(3), Register(4),
            Xor_P64 Register(3), Register(3), Register(4),
            Lt_P64 Register(3), Register(3), Register(3),
        ],
        ending: Switch(
            Register(12),
            Switch {
                cases: [
                    EBB {
                        actions: [
                            Move Register(2), Register(3),
                            Move Register(3), Register(12),
                        ],
                        ending: Leaf(0x1),
                    },
                ],
                default_: EBB {
                    actions: [
                        Move Register(2), Register(3),
                        Move Register(3), Register(12),
                    ],
                    ending: Leaf(0x0),
                },
            },
        ),
    }
}
