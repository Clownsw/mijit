let ebb = cb::build(&mut |mut b| {
    b.const_binary64(Add, R[4], R[4], 0x523e32f31c82fa38 as i64);
    b.binary64(Xor, R[2], R[4], R[2]);
    b.binary64(Lt, R[4], R[3], R[3]);
    b.guard(R[4], true, cb::build(&mut |b| b.jump(0)));
    b.const_binary64(Add, R[3], R[3], 0x2854088f4544aaa6 as i64);
    b.guard(R[3], false, cb::build(&mut |b| b.jump(1)));
    b.jump(2)
});

dataflow = Dataflow[
    Node(0): (Out(0), Out(1), Out(2), Out(3)) <- Convention (),
    Node(1): (Out(4)) <- Constant(5926230179402938936) (),
    Node(2): (Out(5)) <- Binary(P64, Add) (Out(3), Out(4)),
    Node(3): (Out(6)) <- Binary(P64, Xor) (Out(5), Out(1)),
    Node(4): (Out(7)) <- Binary(P64, Lt) (Out(2), Out(2)),
    Node(5): () <- Guard (Out(7)) after (Node(0)),
    Node(6): (Out(8)) <- Constant(2905957070996286118) (),
    Node(7): (Out(9)) <- Binary(P64, Add) (Out(2), Out(8)),
    Node(8): () <- Guard (Out(9)) after (Node(5)),
    Node(9): () <- Convention (Out(0), Out(6), Out(9), Out(7)) after (Node(8), Node(0), Node(0)),
    Node(10): () <- Convention (Out(0), Out(6), Out(9), Out(7)) after (Node(8), Node(0), Node(0)),
    Node(11): () <- Convention (Out(0), Out(6), Out(2), Out(7)) after (Node(5), Node(0), Node(0)),
]

input_map = {
    Out(0): Register(1),
    Out(1): Register(2),
    Out(2): Register(3),
    Out(3): Register(4),
}

walk {
    colds = {
        Node(5): Cold {
            cases: [Merge {exit: Node(11), leaf: 0x0}],
            default_: (hot path),
        },
        Node(8): Cold {
            cases: [(hot path)],
            default_: Merge {exit: Node(9), leaf: 0x1},
        },
    }
    exit = Node(10): () <- Convention (Out(0), Out(6), Out(9), Out(7)) after (Node(8), Node(0), Node(0))
    leaf = 0x2

    fill = Fill {
        marker: 0x2,
        nodes: [Node(1), Node(2), Node(3), Node(4), Node(5), Node(6), Node(7), Node(8), Node(10)],
        frontier: Frontier {
            effects: {Node(0)},
            inputs: {Out(0), Out(1), Out(2), Out(3)},
        },
    }

    guard_failures = {
        Node(5): GuardFailure {
            cases: [Merge {exit: Node(11), leaf: 0x0}],
            default_: (hot path),
            effects: {Node(0), Node(5)},
            inputs: {Out(0), Out(2), Out(6), Out(7)},
        },
        Node(8): GuardFailure {
            cases: [(hot path)],
            default_: Merge {exit: Node(9), leaf: 0x1},
            effects: {Node(0), Node(8)},
            inputs: {Out(0), Out(6), Out(7), Out(9)},
        },
    }

    fill = Fill {
        marker: 0x2,
        nodes: [Node(1), Node(2), Node(3), Node(4), Node(5), Node(6), Node(7), Node(8), Node(10)],
        frontier: Frontier {
            effects: {Node(0)},
            inputs: {Out(0), Out(1), Out(2), Out(3)},
        },
    }

    variables = {
        Out(0): Register(1),
        Out(1): Register(2),
        Out(2): Register(3),
        Out(3): Register(4),
    }

    instructions = [
        Node(4): (Out(7)) <- Binary(P64, Lt) (Out(2), Out(2)),
        Node(6): (Out(8)) <- Constant(2905957070996286118) (),
        Node(7): (Out(9)) <- Binary(P64, Add) (Out(2), Out(8)),
        Node(1): (Out(4)) <- Constant(5926230179402938936) (),
        Node(5): () <- Guard (Out(7)) after (Node(0)),
        Node(2): (Out(5)) <- Binary(P64, Add) (Out(3), Out(4)),
        Node(8): () <- Guard (Out(9)) after (Node(5)),
        Node(3): (Out(6)) <- Binary(P64, Xor) (Out(5), Out(1)),
    ]
    allocation = [
        Out(7): Register(12),
        Out(8): Register(11),
        Out(9): Register(11),
        Out(4): Register(3), // Clobbers Out(2) which is needed by Node(5)
        Out(5): Register(3),
        Out(6): Register(2),
    ]

    Doing Node(4): (Out(7)) <- Binary(P64, Lt) (Out(2), Out(2))
    Doing Node(6): (Out(8)) <- Constant(2905957070996286118) ()
    Doing Node(7): (Out(9)) <- Binary(P64, Add) (Out(2), Out(8))
    Doing Node(1): (Out(4)) <- Constant(5926230179402938936) ()
    Doing Node(5): () <- Guard (Out(7)) after (Node(0))

    walk {
        colds = {}
        exit = Node(11): () <- Convention (Out(0), Out(6), Out(2), Out(7)) after (Node(5), Node(0), Node(0)),
        leaf = 0x0

        fill = Fill {
            marker: 0x3,
            nodes: [Node(2), Node(3), Node(11)],
            frontier: Frontier {
                effects: {Node(0), Node(5)},
                inputs: {Out(0), Out(1), Out(2), Out(3), Out(4), Out(7)},
            },
        }

        guard_failures = {}

        fill = Fill {
            marker: 0x3,
            nodes: [Node(2), Node(3), Node(11)],
            frontier: Frontier {
                effects: {Node(0), Node(5)},
                inputs: {Out(0), Out(1), Out(2), Out(3), Out(4), Out(7)},
            },
        }

        variables = {
            Out(0): Register(1),
            Out(1): Register(2),
            Out(2): Register(3),
            Out(3): Register(4),
            Out(4): Register(3),
            Out(7): Register(12),
        }

        instructions = [
            Node(2): (Out(5)) <- Binary(P64, Add) (Out(3), Out(4)),
            Node(3): (Out(6)) <- Binary(P64, Xor) (Out(5), Out(1)),
        ]
        allocation = [
            Out(5): Register(4),
            Out(6): Register(2),
        ]

        Doing Node(2): (Out(5)) <- Binary(P64, Add) (Out(3), Out(4))
        Doing Node(3): (Out(6)) <- Binary(P64, Xor) (Out(5), Out(1))

        ret = EBB {
            actions: [
                Binary(Add, P64, Register(4), Register(4), Register(3)),
                Binary(Xor, P64, Register(2), Register(4), Register(2)),
                Move(Register(4), Register(12)),
            ],
            ending: Leaf(0x0),
        }
    }

    Doing Node(2): (Out(5)) <- Binary(P64, Add) (Out(3), Out(4))
    Doing Node(8): () <- Guard (Out(9)) after (Node(5))

    walk {
        colds = {}
        exit = Node(9): () <- Convention (Out(0), Out(6), Out(9), Out(7)) after (Node(8), Node(0), Node(0))
        leaf = 0x1

        fill = Fill {
            marker: 0x3,
            nodes: [Node(3), Node(9)],
            frontier: Frontier {
                effects: {Node(0), Node(8)},
                inputs: {Out(0), Out(1), Out(5), Out(7), Out(9)},
            },
        }

        guard_failures = {}

        fill = Fill {
            marker: 0x3,
            nodes: [Node(3), Node(9)],
            frontier: Frontier {
                effects: {Node(0), Node(8)},
                inputs: {Out(0), Out(1), Out(5), Out(7), Out(9)},
            },
        }

        variables = {
            Out(0): Register(1),
            Out(1): Register(2),
            Out(5): Register(3),
            Out(7): Register(12),
            Out(9): Register(11),
        }

        instructions = [
            Node(3): (Out(6)) <- Binary(P64, Xor) (Out(5), Out(1)),
        ]
        allocation = [
            Out(6): Register(2),
        ]

        Doing Node(3): (Out(6)) <- Binary(P64, Xor) (Out(5), Out(1))

        ret = EBB {
            actions: [
                Binary(Xor, P64, Register(2), Register(3), Register(2)),
                Move(Register(3), Register(11)),
                Move(Register(4), Register(12)),
            ],
            ending: Leaf(0x1),
        }
    }

    Doing Node(3): (Out(6)) <- Binary(P64, Xor) (Out(5), Out(1))

    ret = EBB {
        actions: [
            Binary(Lt, P64, Register(12), Register(3), Register(3)),
            Constant(P64, Register(11), 0x2854088f4544aaa6),
            Binary(Add, P64, Register(11), Register(3), Register(11)),
            Constant(P64, Register(3), 0x523e32f31c82fa38),
        ],
        ending: Switch(
            Register(12),
            Switch {
                cases: [
                    EBB {
                        actions: [
                            Binary(Add, P64, Register(4), Register(4), Register(3)),
                            Binary(Xor, P64, Register(2), Register(4), Register(2)),
                            Move(Register(4), Register(12)),
                        ],
                        ending: Leaf(0x0),
                    },
                ],
                default_: EBB {
                    actions: [
                        Binary(Add, P64, Register(3), Register(4), Register(3)),
                    ],
                    ending: Switch(
                        Register(11),
                        Switch {
                            cases: [
                                EBB {
                                    actions: [
                                        Binary(Xor, P64, Register(2), Register(3), Register(2)),
                                        Move(Register(3), Register(11)),
                                        Move(Register(4), Register(12)),
                                    ],
                                    ending: Leaf(0x2),
                                },
                            ],
                            default_: EBB {
                                actions: [
                                    Binary(Xor, P64, Register(2), Register(3), Register(2)),
                                    Move(Register(3), Register(11)),
                                    Move(Register(4), Register(12)),
                                ],
                                ending: Leaf(0x1),
                            },
                        },
                    ),
                },
            },
        ),
    }
}
