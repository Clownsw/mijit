# Goal

We want to generate x86_64 code directly into RAM, fast. We don't need to be able to assemble any x86_64 instruction. I think a small and fairly regular subset will suffice. This issue chooses the subset and copies the necessary data from reference manuals, noticing only 64-bit mode.


## Sources

[This](https://wiki.osdev.org/X86-64_Instruction_Encoding) looks like a good overview.
[This](https://www.felixcloutier.com/x86/) has encodings.
[This](http://ref.x86asm.net/coder64.html) has decodings, and often reveals the patterns.
[Wikipedia](https://en.wikipedia.org/wiki/X86-64#Differences_between_AMD64_and_Intel_64) has history and some compatibility notes.
[Intel's version](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)
[AMD's version](https://www.amd.com/system/files/TechDocs/24594.pdf)


## Compatibility

The basic x86_64 instruction set is supported by essentially all x86 CPUs back to Intel Sandy Bridge (2011) or newer; AMD Bulldozer (2011) or newer, and all VIA CPUs from about 2011.

### Vector extensions.

We won't have a requirement to vectorise loops for quite some time, but vector registers might be useful for copying bits of memory around and possibly as spill slots.

AVX is supported back to Intel Sandy Bridge (2011) or newer; AMD Bulldozer (2011) or newer, and VIA CPUs since about 2015. I don't think we have any reason to generate different code for different CPUs in this subset. There are still a few CPUs in use that don't support AVX2.

By dropping the AVX requirement and asking for SSE4 instead, we can support Intel's low-power CPUs since about 2014 (Atom Z3xxx). I think there are quite a few of those about, and none of them have AVX registers, apparently. SSE4 was introduced in dribs and drabs; study the history in the unlikely event that it becomes important.

By asking for only SSSE3 we can be compatible back to 2008ish (the first Atoms) but I doubt there are many still in use.

### CPU differences

Don't use these instructions, whose behaviour varies between CPUs:

 - 16-bit branch offsets.
 - Unaligned SSE stores (loads are fine).
 - CMPXCHG16B

### Obsolete

Don't use these, which might not be supported in newer CPUs and OSes:

 - x87
 - MMX
 - 3DNow
 - [XOP](https://en.wikipedia.org/wiki/XOP_instruction_set)



# Encoding concepts

The general format of an x86 instruction is the concatenation of up to six pieces:

 - Legacy prefixes. The main one we need is `REX`. Otherwise we perhaps need only `LOCK`?
 - Opcode. This is a string of 1 to 4 bytes. Sometimes the first byte repurposes the opcode of a legacy prefix that would otherwise be useless; I will treat this as part of the opcode.
 - `ModR/M`. This is one byte. It contains register numbers and provides some opcode bits.
 - `SIB`. This is one byte. It contains register numbers and a 2-bit shift.
 - Displacement. This is an address offset. It can be 1, 2, 4 or 8 bytes. I think we mainly want the 4-byte variant.
 - Immediate. This is a constant operand.  It can be 1, 2, 4 or 8 bytes. I think we mainly want the 4-byte and 8-byte variants.

The opcode is always present. Depending on the opcode, the `ModR/M` byte might be present. Depending on the `ModR/M` byte, the `SIB` byte might be present. The `ModR/M` byte also determines the presence and size of the displacement, whereas the opcode determines the presence and size of the immediate.


## Patterns

For each instruction we want to assemble, I suggest we view the `REX` byte, the opcode bytes, and the `ModR/M` and `SIB` bytes as an indivisible string of 2 to 7 bytes, which I will call a "pattern". We can write a whole pattern into the instruction buffer as a 64-bit integer (corrupting some following bytes). The `REX` byte is always in byte 0 in the pattern, but the last two bytes could be anywhere from byte 2 to byte 7.

If a displacement or immediate is required, I suggest we separately write it into the instruction buffer as an integer.

### Naming patterns

Let's name the patterns with a string of the letters "ROMS" each representing one byte (`REX`, opcode, `ModR/M`, `SIB`). The letter "O" can be repeated. Please maintain this enumeration of the patterns we need:

 - RO
 - ROM
 - ...

Note that e.g. the ROM pattern can be used with `reg` as a source and `rm` as a destination, or vice versa. Arguably these are different patterns, but I have not so far given them different names.


## `REX`

I suggest we always assemble a [`REX` prefix](https://wiki.osdev.org/X86-64_Instruction_Encoding#REX_prefix). This gives access to registers 8 to 15 and to the registers `SPL`, `BPL`, `SIL` and `DIL` (which are aliases for the low byte of `SP`, `BP`, `SI` and `DI` respectively). It also makes the encoding of register numbers more regular, and explicitly specifies whether to use 32-bit or 64-bit arithmetic.

A few relevant instructions always use 64-bit operands, with or without a `REX` prefix. They are `CALL`, `JMP`, `Jcc`, `PUSH` and `POP`. There is very little downside to putting a `REX` prefix on these too, though it will only be useful for instructions that mention a register.

The [encoding](https://wiki.osdev.org/X86-64_Instruction_Encoding#Encoding) is the union of the following bitmasks:

 - 0x40 - always (identifies a `REX` prefix)
 - 0x08 - W (1 means 64-bit, 0 means default, usually 32-bit)
 - 0x04 - R (top bit of the register number whose bottom bits are in the `reg` field of the ModR/M byte)
 - 0x02 - X (top bit of the register number whose bottom bits are in the `index` field of the SIB byte)
 - 0x01 - B (top bit of the register number whose bottom bits are in the `rm` field of the ModR/M byte or the `base` field of the SIB byte)

An alternative to a `REX` prefix is a [`VEX` prefix](https://wiki.osdev.org/X86-64_Instruction_Encoding#VEX.2FXOP_opcodes); I don't think we need it.


## opcode

There are several possible opcode encodings. So far, I have only needed 1-byte opcodes.


## Operands

Instructions which only have one operand sometimes omit the `ModR/M` byte. The bottom three bits of the register number are encoded in the `rd` field (bits 0, 1 and 2) of the opcode and the top bit in the `R` bit of the `REX` byte.

More often, one-operand instructions are encoded as two-operand instructions, with the bits that would otherwise be used to encode `reg` used as an opcode extension. A commonly used notation for identifying these cases is to write "opcode/reg", where "opcode" is the opcode byte and "reg" is the `reg` value.

Two-operand instructions are generally encoded with the bottom three bits of the register numbers in the `reg` and `rm` fields of the `ModR/M` byte, and the top bit in the `R` and `B` bits of the `REX` byte.

The second operand (`B.rm`) of instructions with a `ModR/M` byte can alternatively be a memory location. In all cases that I recommend using, the effective address used for accessing memory is the sum of three components:

 - `base` or `rm` (a register)
 - `index` (a register) shifted left by `scale` (a 2-bit immediate constant)
 - `displacement` (an immediate constant)

`base`, `index` and `scale` all come from the `SIB` byte; if it is absent then `rm` is used instead of `base` and zero is used instead of `index`.

The detailed encoding follows.

### `ModR/M`

The presence of a [`ModR/M`](https://wiki.osdev.org/X86-64_Instruction_Encoding#ModR.2FM) byte is indicated by the opcode.

The `ModR/M` byte has three fields:

 - `rm` - bits 0, 1 and 2 - bottom three bits of the register number whose top bit is in `REX.B`
 - `reg` - bits 3, 4 and 5 - bottom three bits of the register number whose top bit is in `REX.R`
 - `mod` - bits 6 and 7 - interpreted as follows provided `rm` is not 100 (`SP` or `R12`):
   - 00 - I recommend we only use this in combination with a `SIB` byte, or for program-relative addressing.
   - 01 - word at address `rm` plus an 8-bit displacement. Perhaps we don't need this.
   - 10 - word at address `rm` plus a 32-bit displacement.
   - 11 - the register `rm` itself.

Sometimes, the `reg` field is used as an opcode. When it is a register number, it can be a source or a destination. `rm` can also be a source or a destination.

### `SIB`

A `SIB` byte always follows a `ModR/M` byte, I think, because the presence of a `SIB` byte is indicated by setting the `rm` field of the `ModR/M` byte to 100 (which would otherwise indicate `SP` or `R12`).

The `SIB` byte has three fields:

 - `base` - bits 0, 1 and 2 - bottom three bits of the register number whose top bit is in `REX.B`. Note that a `SIB` byte can only be present if the `rm` field of `ModR/M` is not a register number; the `base` register number essentially replaces the missing `rm` register number.
 - `index` - bits 3, 4 and 5 - bottom three bits of the register number whose top bit is in `REX.X`.
 - `scale` - bits 6 and 7 - a 2-bit shift distance.


# Registers

Theoretically we have 16 general purpose registers available. In practice we have somewhere between 11 and 14, because:

 - `SP` and `R12` cannot be used in the `rm` field of the `ModR/M` byte, because the bit pattern 100 is used to indicate the presence of a `SIB` byte. Moreover, `SP` cannot be used as the `index` field of a `SIB` byte, because the bit pattern 100 is used to indicate a zero index.
 - `A` and `D` have special roles in some instructions, e.g. long multiplication, and `C` has a special role for shifting by a computed amount. These might be a good choice for temporary workspace registers, or alternatively we can teach our register allocator the constraints.

## Fixed registers

Mijit needs a few "ambient" values which could compete for register space:

 - We need a stack pointer. I suggest we use `SP` as it has special powers.
 - We need to reserve a register to point to the read/writable data block. I suggest we use `R12`.
 - We need a frame pointer. I suggest we store it in memory, maybe at some offset in the data block.

Virtual machine registers, including `PC` and `IR`, are not treated specially by Mijit.

## `BP` and `R13` are not special

If the `mod` field of a `ModR/M` byte is 00, then `BP` and `R13` cannot be used in certain positions, because the bit pattern 101 is used variously to indicate program-relative addressing or a zero `base` value. However, `BP` and `R13` behave exactly the same as any other register provided we avoid that `mod` value, which I recommend we do.

## Byte registers

There is an alias for byte 0 of each register. For example, `AL` is the bottom byte of `A`. I'm not sure if we ever need these. There are alternative ways of loading and storing single bytes, and we don't need 8-bit arithmetic.

We will never need the registers `AH`, `CH`, `BH` or `DH` (which are aliases for byte 1 of the `A`, `C`, `B` and `D` registers).

## Encoding

Registers have 4-bit codes. The top bit goes in the `REX` prefix and the bottom 3 bits typically go in the `ModR/M` byte or in the `SIB` byte. The numbering is as follows:

```
Number  	0	1	2	3	4	5	6	7	8	9	A	B	C	D	E	F
Register	A	C	D	B	SP	BP	SI	DI	R8	R9	R10	R11	R12	R13	R14	R15
```

### Masks

I suggest that for each register we construct a 64-bit mask that includes the register number in all bit positions in which it might be needed. Parts of register numbers appear in various bytes, each of which may be in various positions:

 - The `REX` byte
 - The opcode bytes (only the first?)
 - The `ModR/M` byte, in the `rm` or `reg` fields
 - The `sib` byte, in the `index` or `base` fields

Here are the masks for register numbers 1, 2, 4 and 8, which can be ORed together to obtain all the other register masks:

```
1 - 0x09090909090900
2 - 0x12121212121200
4 - 0x24242424242400
8 - 0x00000000000007
```

For each pattern, we must define three field masks, which can be ANDed with a register mask to leave the register number only in the required position. For example, here are the masks for the "RO", "ROM", "ROMS" and "ROOMS" patterns:

```
pattern	RO    	ROM       	ROMS      	ROOMS
reg    	0x0004	0x380004	0x00380004	0x0038000004
index  	N/A   	N/A         	0x38000002	0x3800000002
rm/base	N/A? 	0x070001	0x00070001	0x0700000001
```



# Recommended instructions

## Move

```
Pattern	Mask       	Dest	Source	Meaning
ROM	0xC08940	rm   	reg  	Move register to register
ROM	0x808940	rm   	reg  	Store register in memory (disp32)
ROM	0xC08B40	reg  	rm   	Move register to register
ROM	0x808B40	reg  	rm   	Load register from memory (disp32)
ROM	0xC0C740	rm   	imm32	Move constant to register (imm32)
ROM	0x80C740	rm   	imm32	Move constant to memory (imm32 disp32)
RO  	0xB840   	rd    	imm32	Move constant to register (imm32)
```

Opcode bytes 0x89 and 0x8B can both be used to move from a register to a register; there doesn't seem to be much to choose between them.

Opcode byte 0xB8 (really 0xB8 to 0xBF) is unusual, in that the destination register is part of the opcode byte. The 64-bit version of this instruction has an 8-byte immediate constant; I think it is the only such opcode.

For 64-bit versions, set the `REX.W` bit. Except for opcode 0xB8, the displacements and immediates remain 4 bytes long (sign extended).


## Binary arithmetic

Add instructions are encoded as follows:

```
Pattern	Mask       	Dest	Source	Meaning
ROM  	0xC08140	rm   	imm32	Add constant to register (imm32)
ROM	0x808140	rm   	imm32	Add constant to memory (disp32 imm32)
ROM	0xC00140	rm   	reg  	Add register to register
ROM	0x800140	rm   	reg  	Add register to memory (disp32)
ROM	0xC00340	reg  	rm   	Add register to register
ROM	0x800340	reg  	rm   	Add memory to register (disp32)
```

Opcode bytes 0x01 and 0x03 can both be used to add a register to a register; there doesn't seem to be much to choose between them.

For 64-bit versions, set the `REX.W` bit. The displacements and the immediates remain 4 bytes long (sign extended).

Other binary arithmetic instructions follow the same basic pattern. It suffices to give, for each version of each arithmetic operation, the value of the opcode byte (byte 1 of the pattern) and, in some cases, the opcode extension in the `reg` field. In general, the following versions exist:

 - Combine a signed immediate constant with `rm`, and write `rm`.
 - Combine `reg` with `rm` and write `rm`.
 - Combine `rm` with `reg` and write `reg`.

```
Operation	ADD	OR  	AND	SUB 	XOR	CMP
const to rm	0x81/0	0x81/1	0x81/4	0x81/5	0x81/6	0x81/7
reg to rm   	0x01	0x09	0x21	0x29	0x31	0x39
rm to reg  	0x03	0x0B	0x23	0x2B	0x33	0x3B
```

Note that opcode byte 0x81 has multiple meanings, disambiguated by a number after a "/". I think this must mean that the `reg` field of the `ModR/M` byte is used as an opcode extension, i.e. `reg` must be set to the number after the "/". Check this! I note also that the number after the "/" in the opcode for the version with an immediate constant matches bits 3, 4 and 5 of the opcode for the other two versions.


## Shifts

Rotate left instructions are encoded as follows:

```
Pattern	Mask       	Dest	Source	Meaning
ROM	0xC0C140	rm   	imm8	Rotate register left by constant (imm8)
ROM	0x80C140	rm    	imm8	Rotate memory left by constant (imm8)
ROM	0xC0D340	rm   	C     	Rotate register left by register
ROM	0x80D340	rm    	C     	Rotate memory left by register
```

The shift amount can be a 1-byte constant, or it can be the value of the C register. Only the bottom 5 bits of the shift amount are used; the other bits are masked to zero.

For 64-bit versions, set the `REX.W` bit. Only the bottom 6 bits of the shift amount are used.

Other shift operations follow the same basic pattern.  It suffices to give, for each version of each shift operation, the value of the opcode byte (byte 1 of the pattern) and the opcode extension in the `reg` field.

```
Operation	ROL	ROR	SAL/SHL	SHR	SAR
rm by const	0xC1/0	0xC1/1	0xC1/4	0xC1/5	0xC1/7
rm by C   	0xD3/0	0xD3/1	0xD3/4	0xD3/5	0xD3/7
```


## Conditional branch

*TODO*


## Unconditional branch

*TODO*


## CALL and RET

*TODO*


## PUSH and POP

*TODO*


## Rare operations

### 8-bit and 16-bit memory access

The `MOVZX` and `MOVSX` instructions are available for loading and storing 8- and 16-bit words (two opcodes each). The `MOVSX` instructions do sign-extension.

A prefix byte of `0x66` on an instruction changes the operand size to 16 bits. I think we probably don't ever need it.

### Atomic operations

I anticipate wanting atomic operations for updating reference counts in Welly.

The [`LOCK` prefix](https://wiki.osdev.org/X86-64_Instruction_Encoding#LOCK_prefix) can be put on read-modify-write instructions to make them atomic. I suggest we special-case the only cases we need (adding or subtracting a constant from a word in memory) and do not bother to generalise everything else.